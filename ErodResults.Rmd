---
title: "Untitled"
author: "Erika Mudrak"
date: "Friday, September 05, 2014"
output: html_document
---

```{r load libraries, echo=FALSE, results='hide', message=FALSE}


library(nlme)
#library(spatstat)
library(devtools)  #do once
install_github("elmR", "emudrak")  #do once, equiv to install.packages()
library(elmR)
#this is a package I wrote with following transformation functions----
logit= function (x) 
{
    if (sum(x[x != 0], na.rm = TRUE) == 0) 
        eps = 0
    else eps = min(x[x != 0], na.rm = TRUE)
    x[x == 0] = 0.5 * eps
    x[x == 1] = 1 - 0.5 * eps
    return(log(x/(1 - x)))
}
inv_logit=function (alpha) 
{
    alpha[alpha > 709] = 709
    return(exp(alpha)/(exp(alpha) + 1))
}
logw0=function (x) 
{
    c = trunc(log(min(x[x > 0], na.rm = T)))
    d = exp(c)
    return(log(x + d) - c)
}
# end (mini) package  -----

#setwd("C:/Users/elm26/Documents/SERDPproject/VegSpatialModeling/VegSpatialModeling")
```



```{r Read in and munge data , echo=FALSE, results='hide'}
# PICK A DESERT
#DESERT="Sonoran"
DESERT="Mojave"
YEAR="2013Xtra"

if((DESERT=="Mojave") & (YEAR=="2013Xtra")){
  CensusData=read.csv("../Mojave2013Intense24Shrubs.csv", blank.lines.skip=TRUE)
  CensusData$Invasives=CensusData$Erodium+CensusData$Schismus+CensusData$Bromus
  Shrubs=read.csv("../CALarreaVolume.csv")
  Shrubs=subset(Shrubs, ShrubID %in% as.character(1:168))
  Shrubs$Shrub=as.numeric(as.character(Shrubs$ShrubID)) 
}

Census=merge(Shrubs[,c("Shrub","Area_Bot","Vol_Bot","Vol_Stem")], CensusData,  by.y="Shrub", by.x="Shrub")

Census$Area_Bot=Census$Area_Bot/10000
Census$Vol_Bot=Census$Vol_Bot/1000000
Census$Vol_Stem=Census$Vol_Stem/1000000

Census=Census[order(Census[,"Shrub"], Census[,"MHcode"]), ]
names(Census)[1]="Shrub"


 
```




```{r Choose Target, results='hide', echo=FALSE}
# Chose target species to model this time --------------
TargSpec="ErodCover"; ylabel="% Cover" 
#TargSpec="Erodium"; ylabel="# Plants" 

Census$Target=round(Census[,TargSpec]) #Round to deal with issue of 0.1 percent cover values
Census$LogitTarg=logit(Census$Target/100)
Census$TargPres=ceiling(Census$Target/100) #Make a new binary variable showing zero or not
```



```{r Training/Testing Data, results='hide', echo=FALSE}
# Make training and Testing Data- ------------
# balance out Fire, Rain and TranDir, 7 of each shrub 
#  Withhold two in each category for testing
set.seed(81)
BurnAmbN=sample(unique(subset(Census, (Fire=="B")&(Rain=="A")&(TranDir=="N"))$Shrub), 2)
BurnAmbS=sample(unique(subset(Census, (Fire=="B")&(Rain=="A")&(TranDir=="S"))$Shrub), 2)
BurnDrtN=sample(unique(subset(Census, (Fire=="B")&(Rain=="D")&(TranDir=="N"))$Shrub), 2)
UnBurnAmbN=sample(unique(subset(Census, (Fire=="UB")&(Rain=="A")&(TranDir=="N"))$Shrub), 2)
UnBurnAmbS=sample(unique(subset(Census, (Fire=="UB")&(Rain=="A")&(TranDir=="S"))$Shrub), 2)
UnBurnDrtN=sample(unique(subset(Census, (Fire=="UB")&(Rain=="D")&(TranDir=="N"))$Shrub), 2)
TestShrubs=c(BurnAmbN, BurnAmbS, BurnDrtN, UnBurnAmbN,  UnBurnAmbS,  UnBurnDrtN)

TestShrubs
#58 131  99  14 124 120 122  80  93  63  69  26


Census.Test=Census[Census$Shrub %in% TestShrubs,]
Census.Train=Census[!(Census$Shrub %in% TestShrubs),]


```


This time using `r TargSpec`

Response seems to be zero-inflated

```{r ExplorDatAnalysis, echo=FALSE, fig.height=3}
par(mfrow=c(1,2))
with(Census.Train, hist(logw0(Target/100), breaks= 40, xlab=paste("log ", ylabel), main=NA))

with(Census.Train,hist(logit(Target/100), breaks= 40, xlab=paste("logit ",ylabel), main=NA))


```

Will dropping the drought treatment fix the zero-inflation problem?

```{r drop drought, echo=FALSE, fig.width=6, fig.height=3}

par(mfrow=c(1,2))
with(subset(Census.Train, Rain=="A"), hist(logw0(Target/100), breaks= 40, xlab=paste("Ambient only, log ", ylabel), main=NA))
with(subset(Census.Train, Rain=="A"),hist(logit(Target/100), breaks= 40, xlab=paste("Ambient only, logit ", ylabel), main=NA))



```

Nope, still looks zero inflated.  Work with whole data, conduct two-stage modeling: Separate processes for if plant presence and cover. 


```{r Plot With transformed response, echo=FALSE}

# Setup for elaborate plotting 
colorset=sample(rainbow(168))
firecols=c("gray40", "green")
watercols=c("lightblue", "tan")
dircols=c("red","blue")
firepch=c(16,1)
dirwds=c(1,2)


#Set scale ranges for this target
xplotmax=max(Census.Train[,"PlotDist"], na.rm=TRUE)
yplotmax=max(Census.Train[,"LogitTarg"])


plotscheme="fire"
plotscheme="rain"
plotscheme="direction"

with(Census.Train, plot(c(1,xplotmax), range(Census.Train$LogitTarg) , pch=NA, main=paste(DESERT, YEAR, TargSpec), ylab=paste("Logit transformmed ", ylabel), xlab="Distance from Shrub Stem" ))
for (i in unique(Census.Train$Shrub)) {  # i=ShrubNumber
    theseplots=Census.Train[Census.Train$Shrub==i,]
    if (plotscheme=="fire") mycol=firecols[theseplots$Fire[1] ] else    
    if (plotscheme=="rain") mycol=watercols[theseplots$Rain[1] ]    else
    if (plotscheme=="direction") mycol=dircols[theseplots$TranDir[1] ]
  lines(theseplots$PlotDist, theseplots$LogitTarg,   
        pch=20,lwd=2, type="o", lty=1,
        col=mycol  )
} # end of i loop
if (plotscheme=="fire") thesecols=firecols else if (plotscheme=="rain")  thesecols=watercols else if (plotscheme=="direction") thesecols=dircols   
legend(200,0.90* yplotmax, levels(Census.Train$Fire), col=thesecols, lwd=2, lty=1, bty="n") 

```


### Hurdle Model------------ 
First fit "hurdle" model, i.e. a presence/absense model indicating whether the plot has plants or not. 
Using only plots from Canopy Dripline and outward (i.e. MHCode > 1)
Model fitting proccess hidden, only final model results shown.

```{r Logistic modeling, echo=FALSE, message=FALSE}
library(lme4)
library(lmerTest)


#fit model process----
# # 
# hurdle1.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle1.lme)
# drop1(hurdle1.lme, test="Chisq")
# 
# hurdle2.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 - PlotDist:Area_Bot  + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle2.lme)
# drop1(hurdle2.lme, test="Chisq")
# 
# 
# hurdle3.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 - PlotDist:Area_Bot - Fire:Rain  + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle3.lme)
# drop1(hurdle3.lme, test="Chisq")
# 
# hurdle4.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 - PlotDist:Area_Bot - Fire:Rain - Area_Bot:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle4.lme)
# drop1(hurdle4.lme, test="Chisq")
# 
# hurdle5.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 - PlotDist:Area_Bot - Fire:Rain - Area_Bot:TranDir - PlotDist:Rain + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle5.lme)
# drop1(hurdle5.lme, test="Chisq")
# 
# hurdle6.lme=glmer(TargPres~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 - PlotDist:Area_Bot - Fire:Rain - Area_Bot:TranDir - PlotDist:Rain - Rain:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle6.lme)
# drop1(hurdle6.lme, test="Chisq")
# 
# hurdle7.lme=glmer(TargPres~ PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:Fire +    
# PlotDist:TranDir + Area_Bot:Rain + Fire:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle7.lme)
# drop1(hurdle7.lme, test="Chisq")
# 
# hurdle7.lme=glmer(TargPres~ PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:Fire +    
# PlotDist:TranDir + Area_Bot:Rain + Fire:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle7.lme)
# drop1(hurdle7.lme, test="Chisq")
# 
# hurdle8.lme=glmer(TargPres~ PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:TranDir + Area_Bot:Rain + Fire:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle8.lme)
# drop1(hurdle8.lme, test="Chisq")
# 
# hurdle9.lme=glmer(TargPres~ PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:TranDir + Area_Bot:Rain + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle9.lme)
# drop1(hurdle9.lme, test="Chisq")
# 
# hurdle10.lme=glmer(TargPres~ PlotDist+Area_Bot+Rain+TranDir + PlotDist:TranDir + Area_Bot:Rain + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle10.lme)
# drop1(hurdle10.lme, test="Chisq")
# 
# hurdle11.lme=glmer(TargPres~ PlotDist+Area_Bot+Rain+TranDir + PlotDist:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
# summary(hurdle11.lme)
# drop1(hurdle11.lme, test="Chisq")

hurdle12.lme=glmer(TargPres~ PlotDist +Rain+TranDir + PlotDist:TranDir + (1|Shrub), family=binomial, data=Census.Train[Census.Train$MHcode>1,],control = glmerControl(optimizer = "bobyqa"))
summary(hurdle12.lme)
drop1(hurdle12.lme, test="Chisq")


```

What are the fixed effects?  
```{r look at fixed effects}
# Fixed effects
fixef(hurdle12.lme)

```


```{r Try with Testing Data, echo=FALSE}

#Not stochastic, uses population level data for previously unobserved levels
Census.Test$HurdPred=NA
Census.Test[Census.Test$MHcode>1,"HurdPred"]=predict(hurdle12.lme,  newdata=Census.Test[Census.Test$MHcode>1,], allow.new.levels=TRUE )

plot(jitter(TargPres,factor=0.2)~inv_logit(HurdPred), data=Census.Test[Census.Test$MHcode>1,], xlab="Probability of presence", ylab="Observed presence (jittered)" ) 


#Try to predict by equation....
#logitP
Eq=with(Census.Test,   3.748875457      -0.000842722*PlotDist      -5.686315700*(Rain=="D")       -4.259545202  *(TranDir=="S") +     0.025186048 *PlotDist*(TranDir=="S"))
Fn=predict(hurdle12.lme,  newdata=Census.Test, allow.new.levels=TRUE )
# plot(Eq, Fn, abline(c(0,1)))


```
Not bad!  

### Now model presence-only ------------
Now fit a model where if present, how much cover a is in a plot?  
Using only non-empty plots from Canopy Dripline and outward (i.e. MHCode > 1 & Census.Test$Target>0)
Model fitting proccess hidden, only final model results shown.

```{r presence-only lme, echo=FALSE}
library(lme4)
library(lmerTest)
# 
# 
# linmod1.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2-Rain:TranDir+(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod1.lme)
# drop1(linmod1.lme, test="Chisq")
# 
# linmod2.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 -Rain:TranDir - PlotDist:Rain +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod2.lme)
# drop1(linmod2.lme, test="Chisq")
# 
# linmod3.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 -Rain:TranDir - PlotDist:Rain - Area_Bot:Rain  +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod3.lme)
# drop1(linmod3.lme, test="Chisq")
# 
# linmod4.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 -Rain:TranDir - PlotDist:Rain - Area_Bot:Rain - PlotDist:Fire  +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod4.lme)
# drop1(linmod4.lme, test="Chisq")
# 
# linmod5.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 -Rain:TranDir - PlotDist:Rain - Area_Bot:Rain - PlotDist:Fire -Fire:Rain  +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod5.lme)
# drop1(linmod5.lme, test="Chisq")
# 
# linmod6.lme=lmer(LogitTarg~(PlotDist+Area_Bot+Fire+Rain+TranDir)^2 -Rain:TranDir - PlotDist:Rain - Area_Bot:Rain - PlotDist:Fire -Fire:Rain - PlotDist:TranDir +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod6.lme)
# drop1(linmod6.lme, test="Chisq")
# 
# 
# linmod7.lme=lmer(LogitTarg~PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:Area_Bot  + Area_Bot:Fire  + Fire:TranDir+(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod7.lme)
# drop1(linmod7.lme, test="Chisq")
# 
# 
# linmod8.lme=lmer(LogitTarg~PlotDist+Area_Bot+Fire+Rain+TranDir + PlotDist:Area_Bot  + Area_Bot:Fire  +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
# summary(linmod8.lme)
# drop1(linmod8.lme, test="Chisq")

linmod9.lme=lmer(LogitTarg~PlotDist+Area_Bot+Fire+Rain + PlotDist:Area_Bot  + Area_Bot:Fire  +(1|Shrub), data=Census.Train[Census.Train$MHcode>1 & Census.Train$Target>0,])
summary(linmod9.lme)
drop1(linmod9.lme, test="Chisq")

```
Model Diagnostics

Residual plot looks ok, residuals a little leptokurtic, but at least centered
```{r Model diagnostics, echo=FALSE, fig.height=3.5}
par(mfrow=c(1,3))
plot(fitted(linmod9.lme), resid(linmod9.lme), abline(c(0,0), lty=2))
qqnorm(resid(linmod9.lme))
abline(c(0,1))
hist(resid(linmod9.lme), breaks=40, freq=F)
curve(dnorm(x, mean=mean(resid(linmod9.lme)), sd=sd(resid(linmod9.lme))), add=TRUE)
#Go with this one for now???

```

```{r Presence Only fixed effects}
# Fixed effects
fixef(linmod9.lme)

```
Try on Testing Data. 
Not stochastic, uses population level data for previously unobserved levels

```{r Testing Data, echo=FALSE}


Census.Test$PresOnlyPred=NA
Census.Test[Census.Test$MHcode>1 & Census.Test$Target>0,"PresOnlyPred"]=predict(linmod9.lme,  newdata=Census.Test[Census.Test$MHcode>1& Census.Test$Target>0,], allow.new.levels=TRUE )

plot(Target/100~inv_logit(PresOnlyPred), data=Census.Test[Census.Test$MHcode>1& Census.Test$Target>0,], xlab="Predicted Percent Cover", ylab="Observed percent Cover" ) 
abline(0,1, lty=2)

```

Not Great.